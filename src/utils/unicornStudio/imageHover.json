{
  "history": [
    {
      "visible": true,
      "aspectRatio": 1,
      "layerType": "effect",
      "type": "fbm",
      "speed": 0.25,
      "texture": false,
      "parentLayer": "f92add83-920f-417b-b13f-b73b476ffb6e",
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t; }float hash31(vec3 p3) { p3 = fract(p3 * vec3(.1031,.11369,.13787)); p3 += dot(p3, p3.yzx + 19.19); return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z); } vec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(.1031,.11369,.13787)); p3 += dot(p3, p3.yxz+19.19); return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x)); }float perlin_noise(vec3 p) { vec3 pi = floor(p); vec3 pf = p - pi; vec3 w = pf * pf * (3.0 - 2.0 * pf); return mix( mix( mix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))), w.x), mix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))), w.x), w.z), mix( mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))), w.x), mix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))), w.x), w.z), w.y); }const int OCTAVES = 6; const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float fbm (in vec3 st) { float value = 0.0; float amp = .25; float frequency = 0.; float aM = (0.1 + 0.50 * .65); vec2 shift = vec2(100.0); mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5)); for (int i = 0; i < OCTAVES; i++) { value += amp * perlin_noise(st); st.xy *= rot * 2.5; st.xy += shift; amp *= aM; } return value; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; float multiplier = 6.0 * (0.20 / ((aspectRatio + 1.) / 2.));vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); vec2 pos = vec2(0.5, 0.5); float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00)));if(dist < distance(uv, mPos)) { vec4 color = texture(uTexture, uv); if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = color * (maskColor.a * maskColor.a); } else { fragColor = color; }}vec2 st = (uv * vec2(aspectRatio, 1) + (1. - pos) - vec2(1)) * multiplier * aspectRatio; st = rot(0.17 * -1. * 2.0 * PI) * st; vec2 drift = vec2(uTime * 0.005);float time = uTime * 0.025;vec2 r = vec2( fbm(vec3(st - drift + vec2(1.7, 9.2), 0.00*25. + time)), fbm(vec3(st - drift + vec2(8.2, 1.3), 0.00*25. + time)) );float f = fbm(vec3(st + r - drift, 0.00*25. + time)) * 0.29;vec2 offset = (f * 2. + (r * 0.29));vec4 color = texture(uTexture, uv + offset * dist); if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = color * (maskColor.a * maskColor.a); } else { fragColor = color; }}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": {}
    },
    {
      "local": {
        "id": "2aa2126f-f4fe-4ce7-86ca-54758f868d80",
        "canvas": {},
        "ctx": {}
      },
      "visible": true,
      "locked": false,
      "aspectRatio": 1,
      "isElement": true,
      "opacity": 1,
      "displace": 0,
      "trackMouse": 0,
      "blendMode": "NORMAL",
      "bgDisplace": 0,
      "dispersion": 0,
      "axisTilt": 0,
      "layerType": "image",
      "imageLoaded": false,
      "effects": [],
      "size": 0.5710000000000001,
      "rotation": 0,
      "height": 1600,
      "repeat": 0,
      "mask": 0,
      "scaleX": 1,
      "scaleY": 1,
      "src": "https://assets.unicorn.studio/images/Q7oJJK6PDEhV0T4NU62JqzVxyeL2/670x800_julian_fella.jpg",
      "speed": 0.5,
      "thumb": "https://assets.unicorn.studio/images/Q7oJJK6PDEhV0T4NU62JqzVxyeL2/670x800_julian_fella_@thumbnail.jpg?authuser=0",
      "translateX": 0.7600000000000477,
      "translateY": 5.400000000000034,
      "width": 1340,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.00); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); uv = perspectiveUV(uv) - pos; vec4 color = texture(uTexture, uv); vec4 background = texture(uBgTexture, vTextureCoord); color = mix(background, color, color.a * 1.00); fragColor = color/(color.a + 0.0000000000001); }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ]
    },
    {
      "visible": true,
      "aspectRatio": 1,
      "layerType": "effect",
      "type": "vignette",
      "texture": false,
      "parentLayer": "94dc7b54-df3b-4820-b1c1-af8f4356943e",
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src; }out vec4 fragColor; void main() { vec2 uv = vTextureCoord;vec4 color = texture(uTexture, uv); float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.00 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.) * vec2(0.50, 1.-0.50); float scaledRadius = 0.10 * 0.5;float adjustedRadius = scaledRadius + 0.00 * scaledRadius; float innerEdge = scaledRadius - 0.00 * scaledRadius * 0.5; float outerEdge = scaledRadius + 0.00 * scaledRadius * 0.5;vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 1.00);float radius = length(uv * aspectRatio - pos * aspectRatio); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);if(0 > 0) { vec3 blended = blend(0, vec3(0, 0, 0), color.rgb); color.rgb = mix(color.rgb, blended, falloff * 1.00); } else { color.rgb = mix(color.rgb, mix(color.rgb, vec3(0, 0, 0), 1.00), falloff); } if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = color * (maskColor.a * maskColor.a); } else { fragColor = color; }}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": {}
    },
    {
      "local": {
        "id": "a50d6b81-c2dc-4b95-8c54-84d162e6ab97",
        "canvas": {},
        "ctx": {}
      },
      "visible": true,
      "locked": false,
      "aspectRatio": 0.85,
      "isElement": true,
      "opacity": 0.15,
      "displace": 0,
      "trackMouse": 0,
      "blendMode": "ADD",
      "bgDisplace": 0,
      "dispersion": 0,
      "axisTilt": 0,
      "layerType": "shape",
      "borderRadius": 0,
      "coords": [
        [-4, 1],
        [505, 1],
        [505, 598],
        [-4, 598]
      ],
      "effects": [
        "94dc7b54-df3b-4820-b1c1-af8f4356943e",
        "a3cb0e44-87ac-4b27-8362-99f24577f6e9",
        "b6f84fdc-55f1-44cb-9de3-b59761d9be88",
        "8e2ce0bc-3878-48f9-857e-f40027a4b0aa"
      ],
      "fill": ["#FFFFFF"],
      "gradientAngle": 0,
      "gradientType": "linear",
      "mask": 0,
      "rotation": 0,
      "translateX": 3,
      "translateY": 0,
      "type": "rectangle",
      "numSides": 3,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uMaskTexture; uniform sampler2D uTexture;vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }const float STEPS = 24.0; const float PI = 3.1415926;vec3 refrakt(vec3 eyeVector, vec3 normal, float iorRatio) { float dotProduct = dot(eyeVector, normal); float k = 1.0 - iorRatio * iorRatio * (1.0 - dotProduct * dotProduct); if (k < 0.0) { return reflect(eyeVector, normal); } else { return iorRatio * eyeVector - (iorRatio * dotProduct + sqrt(k)) * normal; } }vec4 displacement (vec2 st, vec4 bg, vec4 color) { if(0.00 == 1.0) { vec2 refraction = refrakt(vec3(vTextureCoord, 0.5), color.rgb, 0.00-0.5).xy; vec2 displaced = vTextureCoord + mix(vec2(0), refraction * 0.1, 0.00); vec4 bgDisp = texture(uBgTexture, displaced); bgDisp.rgb = bgDisp.rgb; return bgDisp * color.a; } else { vec2 normal = vec2(bg.r * 2.0 - 1.0, bg.g * 2.0 - 1.0) * 0.1; if(0.00 == 1.) { return texture(uMaskTexture, st + normal * 0.00) * texture(uTexture, st + normal * 0.00).a; } else { return texture(uTexture, st + normal * 0.00); } } }vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.00); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); uv = perspectiveUV(uv) - pos; vec4 maskColor = texture(uMaskTexture, vTextureCoord); vec4 base = texture(uTexture, uv); vec4 background = texture(uBgTexture, vTextureCoord); vec4 color = base;if (0.00 == 1.) { color = maskColor * color.a; }if (0.00 > 0.) { if(0.00 == 1.) { color = displacement(uv, background, maskColor); } else { color = displacement(uv, background, color); } }if (1 > 0) { color.rgb = blend(1, color.rgb, background.rgb) * color.a; }color = mix(background, color, color.a * 0.15); fragColor = color.a > 0.0000001 ? (color / color.a) : color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ]
    },
    {
      "visible": true,
      "aspectRatio": 1,
      "layerType": "effect",
      "type": "mouse",
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;uniform float uTime;const float PI = 3.1415926;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_abberation(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) { return a + b*cos( 6.28318*(c*t+d) ); }vec2 pixelate(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; float scale = 0.00/2.; vec2 modulate = mod(vec2(uv.x * aspectRatio, uv.y) - 0.5, (scale + 0.01) / 12.); return vec2( uv.x - modulate.x / aspectRatio + (0.08333 * scale)/2., uv.y - modulate.y + (0.08333 * scale)/2. ); }const float ITERATIONS = 25.;vec4 pixelTrail(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); vec2 distorted = mouseDir * 0.4; vec2 pixelated = mix(uv, pixelate(uv), strength) - distorted; color = texture(uTexture, pixelated); color.rgb = chromatic_abberation(color.rgb, pixelated, distorted*1.00*0.15); return color; }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float aspectRatio = uResolution.x/uResolution.y;return pixelTrail(uv, mouseDir, strength); }void main() { vec2 uv = vTextureCoord; vec3 mouseRgb = texture(uPingPongTexture, uv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (0.20 * 2.); vec2 direction = vec2(cos(angle * 2. * PI), sin(angle * 2. * PI)); vec2 mouseDir = direction * strength; vec4 color = getTrailColor(uv, mouseDir, strength);fragColor = color; }",
        "#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uMousePos; uniform vec2 uPreviousMousePos; uniform vec2 uResolution; uniform float uTime;const float PI = 3.1415926;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 liquify(vec2 st, float angle) { float aspectRatio = uResolution.x / uResolution.y; st.x *= aspectRatio; st = st * rot(angle * 2. * PI); float amplitude = 0.003; for(float i = 1.0; i <= 5.0; i++) { st = st * rot(i/5. * PI * 2.); st += vec2( amplitude * cos(i * 5.0 * st.y + uTime * 0.02), amplitude * sin(i * 5.0 * st.x + uTime * 0.02) ); } st = st * rot(angle * -1. * 2. * PI); st.x /= aspectRatio; return st; }const float TWOPI = 6.2831852; const float edgeSoftness = 0.75; void main() { float aspectRatio = uResolution.x/uResolution.y; vec2 uv = vTextureCoord; vec2 dir = normalize(uMousePos - uPreviousMousePos); float strength = length(uMousePos - uPreviousMousePos); float rad = 0.90 * 0.4 * mix(aspectRatio, 1., 0.5); float angle = atan(dir.y, dir.x); angle += angle < 0. ? TWOPI : 0.; uv = mix(uv, liquify(uv, smoothstep(0., 1., angle)), 1.00);vec2 interpolatedMousePos = mix(uPreviousMousePos, uMousePos, 0.5);float s1 = smoothstep(rad, rad * 0.40, distance(uv * vec2(aspectRatio, 1), uMousePos * vec2(aspectRatio, 1))); float s2 = smoothstep(rad, rad * 0.40, distance(uv * vec2(aspectRatio, 1), interpolatedMousePos * vec2(aspectRatio, 1))); float s3 = smoothstep(rad, rad * 0.40, distance(uv * vec2(aspectRatio, 1), uPreviousMousePos * vec2(aspectRatio, 1)));s1 = (s1 + s2 + s3)/3.;vec3 color = vec3(0.8333, 1, 1); color.x = angle / TWOPI; vec3 mouseColor = hsv2rgb(color);vec3 lastFrameColor = texture(uPingPongTexture, mix(uv, uv/1.03 + 0.015, 1.00)).rgb;vec3 draw = mix(lastFrameColor, mouseColor, strength * s1);fragColor = vec4(draw * pow(0.15, 0.1), 1); }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;uniform sampler2D uPingPongTexture;out vec3 vVertexPosition; out vec2 vTextureCoord;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }const float PI = 3.1415926;void main() {vec3 vertexPosition = aVertexPosition;gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0); vTextureCoord = aTextureCoord; }",
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec3 vVertexPosition; out vec2 vTextureCoord;void main() {vec3 vertexPosition = aVertexPosition;gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0); vTextureCoord = aTextureCoord; vVertexPosition = vertexPosition; }"
      ],
      "data": {}
    },
    {
      "visible": true,
      "aspectRatio": 1,
      "layerType": "effect",
      "type": "fbm",
      "speed": 0.25,
      "texture": false,
      "parentLayer": "8e2ce0bc-3878-48f9-857e-f40027a4b0aa",
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t; }float hash31(vec3 p3) { p3 = fract(p3 * vec3(.1031,.11369,.13787)); p3 += dot(p3, p3.yzx + 19.19); return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z); } vec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(.1031,.11369,.13787)); p3 += dot(p3, p3.yxz+19.19); return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x)); }float perlin_noise(vec3 p) { vec3 pi = floor(p); vec3 pf = p - pi; vec3 w = pf * pf * (3.0 - 2.0 * pf); return mix( mix( mix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))), w.x), mix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))), w.x), w.z), mix( mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))), w.x), mix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))), w.x), w.z), w.y); }const int OCTAVES = 6; const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float fbm (in vec3 st) { float value = 0.0; float amp = .25; float frequency = 0.; float aM = (0.1 + 0.81 * .65); vec2 shift = vec2(100.0); mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5)); for (int i = 0; i < OCTAVES; i++) { value += amp * perlin_noise(st); st.xy *= rot * 2.5; st.xy += shift; amp *= aM; } return value; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; float multiplier = 6.0 * (0.23 / ((aspectRatio + 1.) / 2.));vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); vec2 pos = vec2(0.5, 0.5); float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00)));if(dist < distance(uv, mPos)) { vec4 color = texture(uTexture, uv); if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = color * (maskColor.a * maskColor.a); } else { fragColor = color; }}vec2 st = (uv * vec2(aspectRatio, 1) + (1. - pos) - vec2(1)) * multiplier * aspectRatio; st = rot(0.00 * -1. * 2.0 * PI) * st; vec2 drift = vec2(uTime * 0.005);float time = uTime * 0.025;vec2 r = vec2( fbm(vec3(st - drift + vec2(1.7, 9.2), 0.00*25. + time)), fbm(vec3(st - drift + vec2(8.2, 1.3), 0.00*25. + time)) );float f = fbm(vec3(st + r - drift, 0.00*25. + time)) * 0.24;vec2 offset = (f * 2. + (r * 0.24));vec4 color = texture(uTexture, uv + offset * dist); if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = color * (maskColor.a * maskColor.a); } else { fragColor = color; }}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": {}
    }
  ],
  "options": "myNdurW6zb8lw4aVaq0f",
  "version": "1.2.0"
}
